#include <Arduino.h>
#include "driver/ledc.h"

#define ADC_VREF_mV 3300.0
#define ADC_RESOLUTION 4096.0
#define PIN_LM35 36

//Pines para la lectura del ADC y el botón
#define pinADC 33 
#define btnTemp 13
//Canales para los leds y pwm
#define pwmChannel 0
#define RedChannel 1
#define GreenChannel 2
#define YellowChannel 3
//Pines para los led RGB
#define ledVerde 23
#define ledAmarillo 22
#define ledRojo 21
//Frecuencia del PWM
#define freqPWM 5000
#define freqPWM1 1000
#define freqPWM2 500
#define resolution 8

int estadoBtn = 0; //estado inicial del botón
int estadoFinal = 0; //estado final del botón
int adcRaw = 0; //valor "crudo" del ADC
int ciclo1 = 0;
int ciclo2 = 0;
int ciclo3 = 0;
int rotacion = 0;

const int segmentPins[] = {2, 4, 15, 5, 19, 12, 14, 27};
const int digitPins[] = {34, 35, 32};

const int servoPin = 18;

ledc_channel_config_t channel_config[3];
ledc_channel_config_t servo_channel_config;

void setup() {
  Serial.begin(115200);
  pinMode(btnTemp, INPUT);
  configurarPWM();

  digitalWrite(ledRojo, LOW);
  digitalWrite(ledVerde, LOW);
  digitalWrite(ledAmarillo, LOW);

  pinMode(servoPin, OUTPUT);
  ledcAttachPin(servoPin, LEDC_CHANNEL_0);

  servo_channel_config.gpio_num = servoPin;
  servo_channel_config.speed_mode = LEDC_HIGH_SPEED_MODE;
  servo_channel_config.channel = LEDC_CHANNEL_0;
  servo_channel_config.intr_type = LEDC_INTR_DISABLE;
  servo_channel_config.timer_sel = LEDC_TIMER_0;
  servo_channel_config.duty = 75;
  ledc_channel_config(&servo_channel_config);

  ledc_timer_config_t timer_config;
  timer_config.speed_mode = LEDC_HIGH_SPEED_MODE;
  timer_config.duty_resolution = LEDC_TIMER_10_BIT;
  timer_config.timer_num = LEDC_TIMER_0;
  timer_config.freq_hz = 80;
  ledc_timer_config(&timer_config);

  for(int i = 0; i < 8; i++) {
    pinMode(segmentPins[i], OUTPUT);
  }

  for(int i = 0; i < 3; i++) {
    pinMode(digitPins[i], OUTPUT);

  }
}

void loop() {
  int adcVal = analogRead(PIN_LM35); //Lectura del sensor de temperatura
  float milliVolt = adcVal * (ADC_VREF_mV / ADC_RESOLUTION);
  float temp = milliVolt / 10; //Convierte el voltaje a temperatura

  int leerTemp = digitalRead(btnTemp); //lee el estado del botón
  if (leerTemp == LOW && estadoFinal == HIGH) {
    adcRaw = analogRead(pinADC);

    float voltaje = adcRaw * (5.0 / 4095);

    float tempF = temp * 9 / 5 + 32; //Conversión de la temperatura en °F

    Serial.print("Temperatura: "); //muestra la temperatura leída 
    Serial.print(temp);
    Serial.println(" °C"); //sistema en Celsius
    Serial.print(" ~ ");
    Serial.print(tempF);
    Serial.print(" °F");

    int integrado = int(temp); //Se refiere a los valores que se desean mostrar en el display
    int decimal = int((temp - integrado) * 10);

    displayDigit(0, integrado | (1 << 7));
    displayDigit(1, decimal);
    displayDigit(2, 0);

    //Mapeo de la temperatura a los valores PWM para los leds
    if (temp <= 37.0) {
      ciclo1 = 0;
      ciclo2 = 255;
      ciclo3 = 0;
      ledcWrite(RedChannel, ciclo1);
      ledcWrite(GreenChannel, ciclo2);
      ledcWrite(YellowChannel, ciclo3);
      rotacion = map(temp, 30, 37, 0, 180);
  } else if(temp >= 37.5) {
      ciclo1 = 255;
      ciclo2 = 0;
      ciclo3 = 0;
      ledcWrite(RedChannel, ciclo1);
      ledcWrite(GreenChannel, ciclo2);
      ledcWrite(YellowChannel, ciclo3);
      rotacion = map(37,5, 40, 180, 0);
  } else if(temp > 37.0 && temp < 37.5) {
      ciclo1 = 0;
      ciclo2 = 0;
      ciclo3 = 255;
      ledcWrite(RedChannel, ciclo1);
      ledcWrite(GreenChannel, ciclo2);
      ledcWrite(YellowChannel, ciclo3);
      rotacion = 90;
  } 
  }

  int pulseWidth = map(rotacion, 0, 180, 1000, 2000);
  ledcWrite(LEDC_CHANNEL_0, pulseWidth);

  estadoFinal = leerTemp;
  delay(10);
}


void configurarPWM(void)
{

ledcSetup(RedChannel, freqPWM, resolution);
ledcSetup(GreenChannel, freqPWM1, resolution);
ledcSetup(YellowChannel, freqPWM2, resolution);

ledcAttachPin(ledRojo, RedChannel);
ledcAttachPin(ledVerde, GreenChannel);
ledcAttachPin(ledAmarillo, YellowChannel);
}

void displayDigit(int digit, int value) {
    digitalWrite(digitPins[digit], LOW);
    for(int i = 0; i < 8; i++) {
      digitalWrite(segmentPins[i], value & (1 << i));
    }
    delayMicroseconds(2000);
    digitalWrite(digitPins[digit], HIGH);
  }


